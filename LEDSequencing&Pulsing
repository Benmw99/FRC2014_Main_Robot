    //*****************************************************************************/
    //*****************************************************************************/
    // Title: Arduino LED Synchronization Breathing and Pulsation Code
    // Author: Brandon Spirito
    // Date Created: 2/18/2014
    // 
    //*****************************************************************************/
    // Revision: 1 
    // Date: 2/20/2014
    //
    //*****************************************************************************/
    //
    // Description: This code uses LPD8806-based RGB LED Modules in a strip with a main 
    // objective to provide the driver, shooter, and other team members/friendlies 
    // with visual cues to easily identify articulation movements and other various 
    // components on our 2168 competition robot.
    //
    //
    // 
    //*****************************************************************************/
    //*****************************************************************************/
    
    #include "LPD8806.h"
    #include "SPI.h"
    
    
    // Two LED strips with 8 LEDs per each strip located on the Intake Arm at the rear 
    // of the robot.
    //**These LED strips will be used to tell the driver when the Intake arm is down and 
    // ready to receive a ball.
    //**They will also be used to tell the driver when the intake arm is up.
    
    // Number of LEDs in a strand on both sides of intake arm.
    // Note* there will be two of these wired in parallel to give a ball feed look.
    int IntakeStripLength = 8;      // Number of LEDs * 2 along the rear on the intake arm  
                                    // will use two in parallel for 'feed me' effect.
                                    // [>> >> >> >>] && [<< << << <<]
    int DrivetrainRightLength = 16; // Number of LEDs along the right of the drivetrain
    int DrivetrainLeftLength  = 16; // Number of LEDs along the left of the drivetrain
    int ShooterRightLength    = 14; // Number of LEDs along the left of the shooter
    int ShooterLeftLength     = 14; // Number of LEDs along the right of the shooter
    int FrontLength           = 16; // Number of LEDs along the front 
    
    // Choose output pins
    int dataPin1 = 11; // intake arm
    int dataPin2 = 10; // drivetrain right
    int dataPin3 =  9; // drivetrain left 
    int dataPin4 =  8; // shooter right
    int dataPin5 =  7; // shooter left
    int dataPin6 =  6; // Front 
    
    // Choose clock pin
    int clockPin = 3;  // shared clock

    // First parameter is the number of LEDs in the strand.
    // Next two parameters are SPI data and clock pins.
    
    // Set strip "programming objects" which represent various LED strips.
    // Ths tells the 'strip' object that it is gong to be controlling the LEDs,
    // which are connected to 'dataPin' and 'clockPin'.
    LPD8806 strip1 = LPD8806(IntakeStripLength,     dataPin1, clockPin);
    LPD8806 strip2 = LPD8806(DrivetrainRightLength, dataPin2, clockPin);
    LPD8806 strip3 = LPD8806(DrivetrainLeftLength,  dataPin3, clockPin);
    LPD8806 strip4 = LPD8806(ShooterRightLength,    dataPin4, clockPin);
    LPD8806 strip5 = LPD8806(ShooterLeftLength,     dataPin5, clockPin);
    LPD8806 strip6 = LPD8806(FrontLength,           dataPin6, clockPin);
    
    // LPD8806 strip = LPD8806(IntakeStripLength) for default pins 11 and 13
    
    // Initalize Colors
    int targetR = 0,
        targetG = 0,
        targetB = 0,
        R_OUT = 0,
        G_OUT = 0,
        B_OUT = 0;        
   
    
    //*****************************************************************************/
    // Breathe Table - Brightness and Fading Time Cycle
    //*****************************************************************************/
    uint8_t LED_Breathe_Table[]  = 
    {  202, 211, 220, 228, 236, 242, 247, 251, 254, 255, 255, 254, 251, 247, 242, 236,
       228, 220, 211, 202, 192, 182, 172, 161, 151, 141, 131, 121, 112, 103,  95,  87,  
       80,  73,  66, 60,  55,  50,  45,  41,  38,  34,  31,  28,  26,  24,  22,  20,  
       20,  20,  20, 20,  20,  20,  20,  20,  20   };

    #define BREATHE_TABLE_SIZE (sizeof(LED_Breathe_Table))
    #define BREATHE_CYCLE    700   /*breathe cycle in milliseconds*/
    #define BREATHE_UPDATE    (BREATHE_CYCLE / BREATHE_TABLE_SIZE)
    
    //*****************************************************************************/
    
    void setup() {
      // Start up the LED strip
      strip1.begin();
      
      int i, j;
    
      rainbowCycle(1); // Makes it go through the cycle fairly fast.
      
      //*****************************************************************************/
      // Start Up - Run Once
      // Turn on Intake Arm LEDs (check integrity using all colors - i.e. rainbow)
      //*****************************************************************************/
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );  
      //strip1.setPixelColor(q, strip1.Color(0,127,0));
      }
      
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(127, 127, 127)); // White
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(127,   0,   0)); // Red
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(127, 127,   0)); // Yellow
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(  0, 127,   0)); // Green
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(  0, 127, 127)); // Cyan
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(  0,   0, 127)); // Blue
      }
      strip1.show(); // perform show function on first strip only.
      delay(200);
      
      for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(127,   0, 127)); // Violet
      } 
      strip1.show(); // perform show function on first strip only.
      delay(200);
      }
      //*****************************************************************************/
      
   void loop() {
      
      //*****************************************************************************/
      // Intake Arm 'Feed Me' Loop
      //*****************************************************************************/
      // Turn off Intake Arm LEDs (clearing the colors)
      for(int q = 0; q < strip1.numPixels(); q++) {
        strip1.setPixelColor(q, strip1.Color(0,0,0));
      }
      strip1.show(); // perform show function on first strip only.
      
      int cycle;
   
      // LED pulsation
      for (cycle=0; cycle < 1; cycle++) {
        uniformBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 2, 2, 200);
      }
      
      // LED shifting 
      for (cycle=0; cycle < 2; cycle++) {     // 200, 2, 20  //160,2,170
        sequencedBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 200, 2, 20);
      }
      //*****************************************************************************/  
   }
   
   //*****************************************************************************/
   // Rainbow wheel - equal distribution along chain
   //*****************************************************************************/
   void rainbowCycle(uint8_t wait) {
     uint16_t i, j;
     
          
     for (j=0; j < 384 * 5; j++) {     // 5 cycles of all 384 colors in the wheel
       for (i=0; i < strip1.numPixels(); i++) {
         // tricky math! we use each pixel as a fraction of the full 384-color wheel
         // (thats the i / strip.numPixels() part)
         // Then add in j which makes the colors go around per pixel
         // the % 384 is to make the wheel cycle around
         strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );
       }  
       strip1.show();   // write all the pixels out
       delay(wait);
     }
   }
   
   //*****************************************************************************/
   // Pulsation and Sequencing 
   //*****************************************************************************/
    void uniformBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          breatheRed = (r * breatheTable[breatheIndex]) / 256;
          breatheGrn = (g * breatheTable[breatheIndex]) / 256;
          breatheBlu = (b * breatheTable[breatheIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show();   // write all the pixels out
        delay(updatePeriod);
      }
    }

    void sequencedBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
      uint8_t sequenceIndex;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          sequenceIndex = (breatheIndex + (i*4)) % breatheTableSize;
          breatheRed = (r * breatheTable[sequenceIndex]) / 256;
          breatheGrn = (g * breatheTable[sequenceIndex]) / 256;
          breatheBlu = (b * breatheTable[sequenceIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show();   // write all the pixels out
        delay(updatePeriod);
      }
    }
    
    
    //*****************************************************************************/
    // Helper Functions
    //*****************************************************************************/
    //Input a value 0 to 384 to get a color value.
    //The colours are a transition r - g -b - back to r
    uint32_t Wheel(uint16_t WheelPos)
    {
      byte r, g, b;
      switch(WheelPos / 128)
      {
        case 0:
          r = 127 - WheelPos % 128;   //Red down
          g = WheelPos % 128;      // Green up
          b = 0;                  //blue off
          break; 
        case 1:
          g = 127 - WheelPos % 128;  //green down
          b = WheelPos % 128;      //blue up
          r = 0;                  //red off
          break; 
        case 2:
          b = 127 - WheelPos % 128;  //blue down 
          r = WheelPos % 128;      //red up
          g = 0;                  //green off
          break; 
      }
      return(strip1.Color(r,g,b));
    }
    //*****************************************************************************/
